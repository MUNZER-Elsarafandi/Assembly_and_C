Heyy, Letâ€™s Talk About My 68000 to x86_64 Assembly Project!
So, Whatâ€™s This Project Anyway?
Hiii! Iâ€™m Munzer Elsarafandi, a Year 2 student studying Software Development and Cyber Security at SETU Carlow, and this is my Project II for our "Assembly and C Module." I had to take this 68000 assembly program and turn it into x86_64 assembly, and oh my gosh, itâ€™s been a total adventure (and a bit of a headache, haha)! My programâ€™s called sum-program, and itâ€™s supposed to ask you for 2 numbers each round, do that for 3 rounds, keep a running total, and then show you the sums along the way and the final result at the end. I also had to make sure itâ€™s secureâ€”like, no stack messes or buffer overflow stuffâ€”and make sure it stops after exactly 3 rounds, whichâ€¦ well, Iâ€™m still working on that part!
How I Made It Happen (Or Tried To, Haha)
The 68000 code felt like a little brain teaser I had to solve in x86_64. Hereâ€™s how I went about it:

Playing with Registers:So, in the 68000 code, they used D1 and D2 to send numbers to this thing called REGISTER_ADDER. I figured out that in x86_64, I should use rdi and rsi for that, because thatâ€™s how you pass stuff around (I learned about this System V ABI calling convention thing, which was pretty cool!). The result goes into rax, kind of like how D1 gets updated in the original. The running total was in D3, so I picked rbx for that, and for the loop counter (which was D4 in 68000), Iâ€™m using rcx right nowâ€¦ but I think thatâ€™s causing some drama, and Iâ€™ll tell you more about that in a sec!

Showing Stuff and Getting Input:In the 68000 code, they used TRAP #15 to print messages and get inputâ€”like MOVE.B #14, D0 to show a prompt and MOVE.B #4, D0 to grab a number. For x86_64, I switched to Linux syscalls: I use write (with rax set to 1) to print messages, and read (with rax set to 0) to get your input. Oh, and the 68000â€™s SIMHALT to stop the program? I turned that into an exit syscall (rax = 60) in x86_64.

Trying to Loop 3 Times:The 68000 code set a counter to 3 (MOVE.W #3, D4), took away 1 each round (SUBQ.W #1, D4), and kept looping if it wasnâ€™t zero (BNE GAME_LOOP). I tried to do the same thing in x86_64 with mov rcx, 3, dec rcx, and jnz game_loop, but oh boy, itâ€™s not working the way I want it to, and Iâ€™ll spill the beans on that below!


Stuff Iâ€™ve Been Struggling With
Okay, let me tell you about the wild ride Iâ€™ve been on with this project:

Ugh, Why Wonâ€™t It Assemble?So, I tried to assemble my program with nasm -f elf64 sum-program.asm -o sum-program.o, but I got this super annoying error: sum-program.asm:1: error: parser: instruction expected. The first line is literally just a comment (; ================================================================), so I was like, â€œHuh?!â€ Iâ€™m pretty sure thereâ€™s some sneaky invisible character or a file encoding thingâ€”like maybe a byte order mark (BOM)â€”messing it up. Iâ€™m gonna recreate the file using nano to make sure itâ€™s all clean, because the code looks fine to me. This stopped me from running the latest version, but I did manage to run an earlier one to see whatâ€™s going on with the program.

The Loop Is Driving Me Nuts, and Itâ€™s Skipping Stuff!Oh my gosh, this loop thing has been the hardest part by far! The program is supposed to stop after 3 rounds, but it just keeps going for a 4th round, and itâ€™s not even doing the rounds right! When I ran it, it said â€œEnter number:â€, but then it jumped straight to â€œThe sum is:â€ without showing â€œnum1: Xâ€ or even asking for the second numberâ€”I had to stop it with Ctrl+C because it was acting so weird. Iâ€™m pretty sure itâ€™s because Iâ€™m using rcx as my loop counter, but rcx is also getting used in my atoi and print_number functions, which is probably messing everything up. I think I need to switch to a different register, like r15, so it doesnâ€™t get all confused, and maybe add a little safety check like cmp r15, 0; jle exit_loop to make sure it stops after 3 rounds. Iâ€™m also wondering if the terminal or input buffering is messing with me, because the flow is justâ€¦ off. Iâ€™m still trying to figure this out!

Keeping It Safeâ€”Fixing Stack Stuff and Buffer Overflows:Even though the loop is being a pain, I made sure to tackle the security stuff, because thatâ€™s super important! The 68000 code was kind of a messâ€”it didnâ€™t check user input at all, which is a huge no-no. The project spec even showed someone typing a crazy long string that could cause a buffer overflow, which might let someone mess with the memory and do bad stuff. So, in my atoi function (thatâ€™s the part that turns your typed string into a number), I added some safety nets:

I made sure the input isnâ€™t longer than my buffer (16 bytes) with cmp rcx, buffer_len; jae atoi_error, and I also capped it at 10 digits (cmp rcx, 10; jae atoi_error) so it doesnâ€™t get out of hand and cause an overflow.
I checked that every character is actually a digit (cmp rdx, '0'; jb atoi_error and cmp rdx, '9'; ja atoi_error) so if you type something silly like abc, it wonâ€™t freak out.
If the input is weird, I print â€œInvalid input! Using 0.â€ and just use 0 so the program doesnâ€™t crash.For the stack, I tried to be careful too. My register_adder function uses registers (rdi and rsi) to pass numbers, so Iâ€™m not touching the stack there, which is great for avoiding stack-based problems. But I do use push rcx and pop rcx when Iâ€™m clearing the buffer, and push rax and pop rax in atoi when I print an error message. Those are balanced, so theyâ€™re okay, but now that I think about it, using rcx for both the loop counter and buffer clearing might be causing some of my loop issuesâ€”not just with the loop, but itâ€™s also not the safest way to handle the stack. Iâ€™m thinking I should change the buffer clearing to not use the stack at all, maybe with rep stosb and a different register.


Trying to Make It Run Smoothly:I wanted to be smart about how I used registers. I picked rbx to hold the running sum so I wouldnâ€™t have to keep moving it around, but I really need to fix the rcx mess with the loop counter. The register_adder function is nice and tiny (mov rax, rdi; add rax, rsi; ret)â€”just like the 68000 versionâ€”so itâ€™s pretty fast. I also tried not to use any extra syscalls I didnâ€™t need, to keep things nice and efficient.

Dealing with Oopsies:Besides the invalid input stuff, I made sure the program doesnâ€™t just crash if something goes wrong. If you type something thatâ€™s not a number, itâ€™ll use 0 and keep going. I didnâ€™t add checks for super big numbers in the addition part (like if the sum gets too huge), but I could if I wanted toâ€”Iâ€™d just use the jo instruction to catch overflows.


Whatâ€™s in My Project Folder
Hereâ€™s what Iâ€™ve got for you:

sum-program.asm: My main x86_64 assembly program with the security stuff (but still having loop and output issues, sadly).
test_plan.md: A list of test cases I used to check things (I still need to make thisâ€”Iâ€™ve got some ideas below!).
test_script.c: A little C script to test the program automatically (I havenâ€™t made this yet, itâ€™s optional).
demo_video.mp4: A short video of the program running (Iâ€™ll record this once I fix all the issues!).

How You Can Run It (When Itâ€™s Working, Haha)
Iâ€™m working on this on a Linux VM (like the SETU Carlow ones), but Iâ€™m having some trouble right now. Hereâ€™s how you should be able to run it once I fix the assembly error:

Assemble and Link:
nasm -f elf64 sum-program.asm -o sum-program.o
ld sum-program.o -o sum-program

But right now, Iâ€™m getting that â€œparser: instruction expectedâ€ error, so Iâ€™m working on fixing the file to make this work.

Run It:
./sum-program


What Itâ€™s Supposed to Look Like:It should ask you for two numbers 3 times, add them up each time, show the running total, and then stop after the 3rd round. But right now, itâ€™s being super weirdâ€”it says â€œEnter number:â€, then jumps to â€œThe sum is:â€ without showing the first number or asking for the second one, and it doesnâ€™t stop after 3 rounds. Hereâ€™s what it should look like if you type 1 and 1 each time:
Enter number: 1
num1: 1
Enter number: 1
num2: 1
The sum is: 2
Enter number: 1
num1: 1
Enter number: 1
num2: 1
The sum is: 4
Enter number: 1
num1: 1
Enter number: 1
num2: 1
The sum is: 6
Final sum is: 6

Iâ€™m trying so hard to fix the loop and the output skipping so it looks like this!


What Iâ€™ve Tested So Far
Iâ€™m working on a test plan (test_plan.md), but hereâ€™s what Iâ€™ve tried already:

Normal Numbers: I typed 1 and 1, but the program acted all weirdâ€”it skipped straight to â€œThe sum is:â€ and didnâ€™t show â€œnum1: 1â€ or ask for the second number, and it kept going past 3 rounds.
Silly Input: I typed abc for a number, and it said â€œInvalid input! Using 0.â€ and kept going without crashing, which is awesome because it shows my buffer overflow fix is working!
Negative Numbers: I tried -1 and 1, and it added them to 0 each round, which is what itâ€™s supposed to do.

Iâ€™ll write these up properly in the test plan once I get the program behaving!
Whatâ€™s Been Super Hard

That Assembly Error: That â€œparser: instruction expectedâ€ error totally threw me for a loop! I think itâ€™s an encoding thing, so Iâ€™m gonna recreate the file to fix it.
The Loop and Output Mess: The program not stopping after 3 rounds and skipping parts of the output is making me pull my hair out! I think itâ€™s because Iâ€™m using rcx for too many things, so I need to switch to something like r15 and maybe add a failsafe. Iâ€™m also wondering if the terminal is messing with me.
Security Stuff: Figuring out how to stop buffer overflows was tricky at first, but Iâ€™m really proud of how I handled it, especially since the 68000 code was totally open to attacks.
Learning Syscalls: Switching from 68000â€™s TRAP #15 to x86_64 syscalls was a bit of a learning curve, but I got there!

How I Can Make It Better

I gotta fix that assembly error by recreating the file and making sure there are no sneaky characters hiding in there.
I need to fix the loop by using a different register than rcx (like r15) and adding a failsafe to stop after 3 rounds. I also need to figure out why the output is skipping stepsâ€”maybe Iâ€™ll use GDB to peek at whatâ€™s going on.
I could make the buffer clearing safer by not using the stack at all, like using rep stosb with a different register.
I could add a check for really big numbers in the addition partâ€”if the sum gets too big, I can catch it with the jo instruction and handle it.
I might write a little C script to test the program automatically, maybe using something like assert.h to check the outputs.

When I Need to Finish This

Deadline: April 28, 2025, 9:00 AM (no GitHub commits after this, eek!).
Demo and Quiz: May 2, 2025, from 9:00 AM to 5:00 PM.

Iâ€™m getting thereâ€”just need to fix the assembly error, the loop issue, and the output problem, then finish the test plan and record that video! Thanks so much for checking out my projectâ€”I really appreciate it! ğŸ˜Š
